<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>

    <body>

    </body>
    <script>

class Node {
    constructor(x, y, g = 0, h = 0) {
        this.x = x;          // x coordinate
        this.y = y;          // y coordinate
        this.g = g;          // Cost from start node to current node
        this.h = h;          // Estimated cost from current node to goal
        this.f = g + h;      // Total estimated cost (f = g + h)
        this.parent = null;  // Parent node for path reconstruction
    }
}

class AStar {
    constructor(grid) {
        this.grid = grid;
        this.rows = grid.length;
        this.cols = grid[0].length;
    }

    // Manhattan distance heuristic
    calculateHeuristic(current, goal) {
        return Math.abs(current.x - goal.x) + Math.abs(current.y - goal.y);
    }

    // Get valid neighboring nodes
    getNeighbors(node) {
        const neighbors = [];
        const directions = [
            [0, 1],   // Right
            [1, 0],   // Down
            [0, -1],  // Left
            [-1, 0]   // Up
        ];

        for (let [dx, dy] of directions) {
            const newX = node.x + dx;
            const newY = node.y + dy;

            // Check if new coordinates are within grid and not an obstacle
            if (
                newX >= 0 && newX < this.rows &&
                newY >= 0 && newY < this.cols &&
                this.grid[newX][newY] !== 1  // 1 represents an obstacle
            ) {
                neighbors.push(new Node(newX, newY));
            }
        }

        return neighbors;
    }

    // Find the path using A* algorithm
    findPath(start, goal) {
        const startNode = new Node(start[0], start[1]);
        const goalNode = new Node(goal[0], goal[1]);

        const openList = [startNode];
        const closedSet = new Set();

        while (openList.length > 0) {
            // Find the node with the lowest f value
            const currentNode = openList.reduce((min, node) => 
                node.f < min.f ? node : min
            );

            // Check if we've reached the goal
            if (currentNode.x === goalNode.x && currentNode.y === goalNode.y) {
                return this.reconstructPath(currentNode);
            }

            // Remove current node from open list and add to closed set
            openList.splice(openList.indexOf(currentNode), 1);
            closedSet.add(`${currentNode.x},${currentNode.y}`);

            // Explore neighbors
            for (let neighbor of this.getNeighbors(currentNode)) {
                // Skip if already explored
                if (closedSet.has(`${neighbor.x},${neighbor.y}`)) continue;

                // Calculate costs
                neighbor.g = currentNode.g + 1;
                neighbor.h = this.calculateHeuristic(neighbor, goalNode);
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = currentNode;

                // Add to open list if not already present
                const existingNodeIndex = openList.findIndex(
                    n => n.x === neighbor.x && n.y === neighbor.y
                );

                if (existingNodeIndex === -1) {
                    openList.push(neighbor);
                } else if (neighbor.g < openList[existingNodeIndex].g) {
                    // Replace if new path is more efficient
                    openList[existingNodeIndex] = neighbor;
                }
            }
        }

        // No path found
        return null;
    }

    // Reconstruct the path from goal to start
    reconstructPath(node) {
        const path = [];
        while (node !== null) {
            path.unshift([node.x, node.y]);
            node = node.parent;
        }
        return path;
    }
}

// Example usage
const grid = [
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [1, 1, 0, 1, 0, 1, 1, 1, 1, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 1, 1],
    [0, 1, 1, 1, 0, 1, 1, 0, 1, 1],
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
    [0, 1, 1, 1, 1, 0, 1, 1, 1, 0],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    [1, 1, 1, 0, 1, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 0]
];

function displayGrid(grid) {
    const gridContainer = document.createElement('div');
    gridContainer.style.display = 'grid';
    gridContainer.style.gridTemplateColumns = `repeat(${grid[0].length}, 20px)`;
    gridContainer.style.gap = '2px';

    for (let row of grid) {
        for (let cell of row) {
            const cellElement = document.createElement('div');
            cellElement.style.width = '20px';
            cellElement.style.height = '20px';
            cellElement.style.backgroundColor = cell === 1 ? 'black' : 'white';
            gridContainer.appendChild(cellElement);
        }
    }

    document.body.appendChild(gridContainer);
}

displayGrid(grid);



const aStar = new AStar(grid);
const start = [0, 0];
const goal = [9, 9];

const path = aStar.findPath(start, goal);
console.log(path);

    </script>
</head>
<body>
    
</body>
</html>